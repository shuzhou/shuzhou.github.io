<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>张书洲的博客</title>
    <link></link>
    <description>My personal blog</description>
    
      <item>
        <title>使用extundelete恢复linux上被删除的文件</title>
        <link>/2016/01/21/use-extundelete-to-restore-the-deleted-file-on-Linux.html</link>
        <guid isPermaLink="true">/2016/01/21/use-extundelete-to-restore-the-deleted-file-on-Linux.html</guid>
        <pubDate>Thu, 21 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;h3&gt;1.背景简述&lt;/h3&gt;

&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;最近项目刚上线，前端有些bug需要修改，然后直接在服务器上进行的修改，我重新部署的时候，打算删了久的备份，然后重新备份一份就部署一下，然后一不小心用了&lt;code&gt;rm -r edu.*&lt;/code&gt;命令，然后以&lt;code&gt;edu&lt;/code&gt;开头的所有的文件夹都被删了（不清楚为啥这个命令会删除掉&lt;code&gt;edu&lt;/code&gt;文件夹，不应该是删除&lt;code&gt;edu.*&lt;/code&gt;文件夹么？），当然也包括这段时间修改好bug代码的&lt;code&gt;edu&lt;/code&gt;文件夹！！然后只能尝试使用恢复软件进行修复。&lt;/p&gt;

&lt;p&gt;使用以上命令删除的是如下所示红色框框中的文件：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/PEPATJV.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;所以以后使用rm 命令一定要三思而后行阿！&lt;/p&gt;

&lt;h3&gt;2.注意事项及常用工具说明&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;其实我们删除文件时，文件在磁盘上并没有真正的删除，只是系统对这些文件进行了删除标记，以后写入新文件时才会覆盖掉这些被删除的文件 &lt;/p&gt;

&lt;p&gt;所以进行文件恢复的时候，一定要记得切勿对原磁盘进行写入操作，最简单的方式是再挂载一块磁盘上去，所有的恢复软件安装及恢复文件的位置全在新的磁盘上进行&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;参考这篇博客&lt;a href=&quot;http://blog.csdn.net/chinalinuxzend/article/details/3990658&quot;&gt;http://blog.csdn.net/chinalinuxzend/article/details/3990658&lt;/a&gt;得知了常用的恢复软件如下&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The Sleuth Kit &lt;a href=&quot;http://www.sleuthkit.org/sleuthkit&quot;&gt;http://www.sleuthkit.org/sleuthkit&lt;/a&gt;[Autopsy是它的一个图形前端)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://foremost.sourceforge.net&quot;&gt;Foremost&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Finaldata[未找到对应的资料]:&lt;/p&gt;

&lt;p&gt;一个全能的工具，Finaldata,可以恢复unix/linux/dos下误删的文件。对于unix，支持这些产品,Solaris、AIX和HP-UX。对于linux，支持EXT2的文件系统。对于dos，支持FAT 12/16/32, NTFS 4/5/5.1 的文件系统。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;debugfs 恢复ext3被rm的资料&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ext4magic&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;e2fsprogs&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;photorec &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.91cto.com.cn/detail/udepnxs/&quot;&gt;参考文章链接&lt;/a&gt;
第一尝试使用的工具就是&lt;code&gt;photorec&lt;/code&gt;,这个工具可以自己指定恢复目录，可以选择恢复文件的格式，但是他的特点如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;恢复文件的目录是 类似recup_dir.1的目录存储的，到达一定数量后会按数字一次新建目录。&lt;/li&gt;
&lt;li&gt;恢复后文件有可能后缀会稍有差别，这是我遇到的情况，有可能之前是png后缀的图片恢复后是gif格式。这有可能和文件头有关系。&lt;/li&gt;
&lt;li&gt;恢复后的文件采用系统规则命名，所以文件名有所改变。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于不能根据删除的目录恢复，所以导致删除文件全在一起，所以其对照片之类的文档恢复绝对是利器，但是针对目前的情况就不适合了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;testdisk
&lt;a href=&quot;http://www.91cto.com.cn/detail/udepnxs/&quot;&gt;参考文章链接&lt;/a&gt;
当时看到了这个感觉简直是神奇阿，可以根据删除的文件夹恢复，所以我当时尝试photorec不理想的情况下，testdisk成为了第二个尝试。
使用过程汇中虽然可以看到删除的文件和文件夹，但是自己恢复出来的文件都是空的，不知道是不是自己使用的方式不对，所以这种工具我使用失败&lt;/li&gt;
&lt;li&gt;&lt;p&gt;extundelete&lt;/p&gt;

&lt;p&gt;看名字就知道专门对于ext文件系统进行文件恢复的工具。下面将会详细介绍。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;3.extundelete使用说明&lt;/h3&gt;

&lt;p&gt;系统中磁盘及分区情况如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/3XDcdJW.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;其中&lt;code&gt;sdb1&lt;/code&gt;是文件被删除之后挂载上去的一块新的磁盘&lt;code&gt;/dev/mapper/Template--vg-root&lt;/code&gt;是被删除文件所在磁盘&lt;/p&gt;

&lt;h4&gt;3.1 安装extundelete&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载文件     &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;wget http://nchc.dl.sourceforge.net/project/extundelete/extundelete/0.2.4/extundelete-0.2.4.tar.bz2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解压后进行编译安装&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;./configure --prefix=/temp-disk/install/
make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;在实际线上恢复过程中，切勿将extundelete安装到你误删的文件所在硬盘，这样会有一定几率将需要恢复的数据彻底覆盖。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;3.2数据恢复&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;任何的文件恢复工具，在使用前，均要将要恢复的分区卸载或挂载为只读，防止数据被覆盖使用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;直接运行对应文件夹下的&lt;code&gt;extundelete&lt;/code&gt;即可&lt;/p&gt;

&lt;p&gt;其中一些参数可以用&lt;code&gt;./extundelete --help&lt;/code&gt;进行查看。&lt;/p&gt;

&lt;p&gt;此处简单介绍几个自己恢复的过程中用到的几个参数：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;--restore-all //恢复所有删除的文件
--restore-dir your_dir/  //恢复your_dir中删除的文件
--after time //恢复指定时间戳(time)之后删除的文件
--before time //恢复指定时间戳(time)之前删除的文件
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例如我是在2016-1-20下午2：00以后删除的文件&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;date -d &quot;Wed Jan 20 14:00:00 CST 2016&quot; +%s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;得出时间戳为1453269600&lt;/p&gt;

&lt;p&gt;例如我需要恢复指定删除的文件夹，则输入如下命令：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;./extundelete  /dev/mapper/Template--vg-root --after 1453269600 --restore-dir /usr/local/tomcat7/webapps/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      </item>
    
      <item>
        <title>VS2013下编译Tesseract-OCR</title>
        <link>/2016/01/16/complie-Tesseract-OCR-use-VS2013.html</link>
        <guid isPermaLink="true">/2016/01/16/complie-Tesseract-OCR-use-VS2013.html</guid>
        <pubDate>Sat, 16 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;h3&gt;1. 所需环境说明&lt;/h3&gt;

&lt;p&gt;因为Tesseract在google code上，所以下载很多东西需要翻墙，如果不能翻墙的同学，可以根据文章整理的&lt;a href=&quot;http://pan.baidu.com/s/1i4s2Rdz&quot;&gt;文件链接&lt;/a&gt;进行打包下载。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://code.google.com/p/tesseract-ocr/&quot;&gt;点此访问Tesseract-ocr Google code主页&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;VS2013(建议版本统一，VS2015编译器增加了新的编译规则会导致代码失败)&lt;/li&gt;
&lt;li&gt;python2.7及以上（由于python3语法不向前兼容python2语法，所以请勿安装python3）&lt;/li&gt;
&lt;li&gt;jdk1.7及以上（图形界面调试环境需要使用）(配置参考&lt;a href=&quot;http://zhangshuzhou.cn/2014/02/11/Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html&quot;&gt;这里&lt;/a&gt;)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;2. 配置目录结构&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://code.google.com/p/leptonica/downloads/detail?name=leptonica-1.68-win32-lib-include-dirs.zip&quot;&gt;下载&lt;/a&gt;&lt;code&gt;leptonica-1.68-win32-lib-include-dirs.zip&lt;/code&gt;，解压到&lt;code&gt;C:\BuildFolder&lt;/code&gt;(此目录可以是任何目录，此处只是以&lt;code&gt;C:\BuildFolder&lt;/code&gt;目录为例)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装linux命令模拟器（因为Leptonica需要使用一些简单的linux命令，例如&lt;code&gt;rm&lt;/code&gt;、&lt;code&gt;diff&lt;/code&gt;、&lt;code&gt;sleep&lt;/code&gt;等），官方推荐&lt;a href=&quot;http://tpgit.github.io/UnOfficialLeptDocs/vs2008/installing-cygwin.html&quot;&gt;cygwin&lt;/a&gt;,下载&lt;code&gt;cygwin.setup-x86_64.exe&lt;/code&gt;安装即可&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;安装过程汇中源的选择需要注意&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;经过以上步骤目录结构为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;C:\BuildFolder\ 

      include\
         leptonica\
         file1
         file2
         ......

      lib\
         giflib416-static-mtdll-debug.lib
         giflib416-static-mtdll.lib
         libjpeg8c-static-mtdll-debug.lib
         libjpeg8c-static-mtdll.lib
         liblept168-static-mtdll-debug.lib
         liblept168-static-mtdll.lib
         liblept168.dll
         liblept168.lib
         liblept168d.dll
         liblept168d.lib
         libpng143-static-mtdll-debug.lib
         libpng143-static-mtdll.lib
         libtesseract302.dll
         libtesseract302.lib
         libtesseract302d.dll
         libtesseract302d.lib
         libtesseract302-static.lib
         libtesseract302-static-debug.lib
         libtiff394-static-mtdll-debug.lib
         libtiff394-static-mtdll.lib
         zlib125-static-mtdll-debug.lib
         zlib125-static-mtdll.lib
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://code.google.com/p/tesseract-ocr/downloads/detail?name=tesseract-ocr-3.02-vs2008.zip&quot;&gt;下载Tesseract-OCR VS2008&lt;/a&gt;工程 &lt;code&gt;tesseract-ocr-3.02-vs2008.zip&lt;/code&gt;，然后将结业文件夹内的&lt;code&gt;tesseract-ocr&lt;/code&gt;文件夹命名为&lt;code&gt;tesseract-3.02&lt;/code&gt;，拷到&lt;code&gt;C:\BuildFolder\&lt;/code&gt;文件夹中&lt;/p&gt;

&lt;p&gt;文件夹结构如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;C:\BuildFolder\

      include\
         leptonica\
      lib\
      tesseract-3.02\
         vs2008\
            ambiguous_words\
            classifier_tester\
            cntraining\
            combine_tessdata\
            dawg2wordlist\
            doc\
            include\
            libtesseract\
               libtesseract.vcproj
            mftraining\
            port\
            shapeclustering\
            sphinx\
            tesseract\
               tesseract.vcproj
            unicharset_extractor\
            wordlist2dawg\

            tesseract.sln
            tesshelper.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下载并解压&lt;a href=&quot;http://code.google.com/p/tesseract-ocr/downloads/detail?name=tesseract-3.02.tar.gz&quot;&gt;Tesseract-OCR源码&lt;/a&gt;文件&lt;code&gt;tesseract-ocr-3.02.02.tar.zip&lt;/code&gt;，将得到的&lt;code&gt;tesseract-ocr&lt;/code&gt;文件夹命名为&lt;code&gt;tesseract-3.02&lt;/code&gt;，拷到&lt;code&gt;C:\BuildFolder\&lt;/code&gt;文件夹中与原有的文件夹合并&lt;/p&gt;

&lt;p&gt;得到如下目录结构:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;C:\BuildFolder\       
      include\
         leptonica\
      lib\
      tesseract-3.02\
         api\
         ccmain\
         ccstruct\
         ccutil\
         classify\
         config\
         contrib\
         cube\
         cutil\
         dict\
         doc\
         image\
         java\
         image\
         neural_networks\
         tessdata\
         testing\
         textord\
         training\
         viewer\
         vs2008\
         wordrec\
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;检查&lt;code&gt;C:\BuildFolder\include\tesseract&lt;/code&gt;是否存在，如过存在则删除。进入&lt;code&gt;C:\BuildFolder\tesseract-3.02\vs2008&lt;/code&gt;目录，打开cmd控制台，然后运行&lt;code&gt;python tesshelper.py .. copy ..\..\include&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;目录结构结果如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;C:\BuildFolder\       
      include\
         leptonica\
         tesseract\
      lib\
      tesseract-3.02\
         api\
         ccmain\
         ccstruct\
         ccutil\
         classify\
         config\
         contrib\
         cube\
         cutil\
         dict\
         doc\
         image\
         java\
         image\
         neural_networks\
         tessdata\
         testing\
         textord\
         training\
         viewer\
         vs2008\
     wordrec\
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;3. 项目编译&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;用VS2013打开&lt;code&gt;C:\BuildFolder\tesseract-3.02\vs2008\tesseract.sln&lt;/code&gt;(忽略2013的提示即可)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在以下四种编译模式中选择一种进行编译&amp;lt;模式名称记为&lt;code&gt;ConfigurationName&lt;/code&gt;&amp;gt;，建议选择&lt;code&gt;DLL_Release&lt;/code&gt;版本（某些机器缺少库，导致DLL_Debug版本无法启动）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;DLL_Debug
DLL_Release
LIB_Debug
LIB_Release
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;首先编译&lt;code&gt;libtesseract302&lt;/code&gt;(在libtesseract302项目上右键-&amp;gt;选择生成)&lt;/p&gt;

&lt;p&gt;编译完成后&lt;code&gt;C:\BuildFolder\tesseract-3.02\vs2008\&amp;lt;ConfigurationName&amp;gt;\&lt;/code&gt;文件夹下新增如下文件：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;static libraries:
   libtesseract302-static.lib
   libtesseract302-static-debug.lib

DLLs:
   libtesseract302.lib  (import library)
   libtesseract302.dll
   libtesseract302d.lib (import library)
   libtesseract302d.dll
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;编译生成的文件会自动拷到&lt;code&gt;C:\BuildFolder\lib&lt;/code&gt;下即可&lt;/p&gt;

&lt;p&gt;编译过程中会出现以下错误：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;1&amp;gt;  equationdetect.cpp
1&amp;gt;..\..\ccmain\equationdetect.cpp : warning C4819: 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失
1&amp;gt;..\..\ccmain\equationdetect.cpp(251): error C2146: 语法错误: 缺少“}”(在标识符“銆”的前面)
1&amp;gt;..\..\ccmain\equationdetect.cpp(251): error C2146: 语法错误: 缺少“;”(在标识符“銆”的前面)
1&amp;gt;..\..\ccmain\equationdetect.cpp(251): error C2065: “銆”: 未声明的标识符
1&amp;gt;..\..\ccmain\equationdetect.cpp(251): error C2146: 语法错误: 缺少“;”(在标识符“銆”的前面)
1&amp;gt;..\..\ccmain\equationdetect.cpp(251): error C2065: “銆”: 未声明的标识符
1&amp;gt;..\..\ccmain\equationdetect.cpp(251): error C2146: 语法错误: 缺少“;”(在标识符“銆”的前面)
1&amp;gt;..\..\ccmain\equationdetect.cpp(251): error C2065: “銆”: 未声明的标识符
1&amp;gt;..\..\ccmain\equationdetect.cpp(251): error C2143: 语法错误 : 缺少“;”(在“}”的前面)
1&amp;gt;..\..\ccmain\equationdetect.cpp(253): error C2065: “kCharsToEx”: 未声明的标识符
1&amp;gt;..\..\ccmain\equationdetect.cpp(253): fatal error C1903: 无法从以前的错误中恢复；正在停止编译
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;解决办法如下：&lt;/p&gt;

&lt;p&gt;打开出错的文件，然后选择vs2013的菜单“文件 -- 高级保存选项”，在窗口中选择“简体中文（gb2312）-代码页936”，保存后重新编译生成&lt;code&gt;libtesseract302&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后再编译&lt;code&gt;tesseract&lt;/code&gt;（在项目tesseract上选择右键生成）&lt;/p&gt;

&lt;p&gt;在对应编译模式的文件夹下将会产生可执行，其可执行文件下所示&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;LIB_Release: tesseract.exe
LIB_Debug:   tesseractd.exe
DLL_Release: tesseract-dll.exe
DLL_Debug:   tesseract-dlld.exe
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;测试的&lt;code&gt;tesseract.exe&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;C:\BuildFolder\&lt;/code&gt;目录下新建一个&lt;code&gt;testing&lt;/code&gt;文件夹，然后将如下文件拷到当前目录&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;liblept168d.dll//在C:\BuildFolder\lib目录下
libtesseract302d.dll//在C:\BuildFolder\lib目录下
tesseract-dll.exe//在C:\BuildFolder\tesseract-3.02\vs2008\&amp;lt;ConfigurationName&amp;gt;目录下
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;选取一张含有文字的截图放到当前目录下，然后打开cmd控制台，输入如下命令进行识别测试&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;tesseract-dll.exe test.jpg out
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果运行成功，会在当前目录下生成out.txt文件，打开即为识别结果&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果提示找不到英语语言包eng.traineddata，可以下载语言包按照提示放到对应目录下。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;4. 安装图形界面调试环境&lt;/h3&gt;

&lt;p&gt;需要jar包列表如下    &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;piccolo2d-core-3.0.jar//编译ScrollView.jar需要的
piccolo2d-extras-3.0.jar//编译ScrollView.jar需要的
ScrollView.jar//已编译好，在附录中
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果有人希望自己编译java代码，可以参考&lt;a href=&quot;https://code.google.com/p/tesseract-ocr/wiki/ViewerDebugging&quot;&gt;官方说明&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;修改源码 &lt;/p&gt;

&lt;p&gt;在&lt;code&gt;tesseract\tesseractmain.cpp&lt;/code&gt;的以下代码&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;if (!api.ProcessPages(image, NULL, 0, &amp;amp;text_out)) {
  fprintf(stderr, _(&quot;Error during processing.\n&quot;));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之前加入&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;api.SetVariable(&quot;tessedit_dump_pageseg_images&quot;, &quot;true&quot;);    //show no lines and no image picture
api.SetVariable(&quot;textord_show_blobs&quot;, &quot;true&quot;);  //show blobs result
api.SetVariable(&quot;textord_show_boxes&quot;, &quot;true&quot;);  //show blobs&#39; bounding boxes
api.SetVariable(&quot;textord_tabfind_show_blocks&quot;, &quot;true&quot;); //show candidate tab-stops and tab vectors
api.SetVariable(&quot;textord_tabfind_show_reject_blobs&quot;, &quot;true&quot;);   //show rejected blobs
api.SetVariable(&quot;textord_tabfind_show_initial_partitions&quot;, &quot;true&quot;); //show initial partitions
api.SetVariable(&quot;textord_tabfind_show_partitions&quot;, &quot;1&quot;);    //show final partitions
api.SetVariable(&quot;textord_tabfind_show_initialtabs&quot;, &quot;true&quot;);    //show initial tab-stops
api.SetVariable(&quot;textord_tabfind_show_finaltabs&quot;, &quot;true&quot;);  //show final tab vectors
api.SetVariable(&quot;textord_tabfind_show_images&quot;, &quot;true&quot;); //show image blobs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上代码控制Tesseract输出所有结果。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启动调试程序&lt;/p&gt;

&lt;p&gt;附件中&lt;code&gt;ScrollView.jar&lt;/code&gt;是已经编译好调试程序，打开控制台输入&lt;code&gt;java -jar ScrollView.jar&lt;/code&gt;即可运行服务端调试程序，如果该文件运行成功会在控制台输出以下信息：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Socket started on port 8461
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启动OCR识别引擎&lt;/p&gt;

&lt;p&gt;打开控制台，输入&lt;code&gt;tesseract-dll.exe test.jpg out&lt;/code&gt;命令启动OCR引擎，即可看到调试界面&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      </item>
    
      <item>
        <title>DiscuzX UCenter KPPW安装与配置</title>
        <link>/2015/07/23/DiscuzX-UCenter-KPPW-install-and-env-config.html</link>
        <guid isPermaLink="true">/2015/07/23/DiscuzX-UCenter-KPPW-install-and-env-config.html</guid>
        <pubDate>Thu, 23 Jul 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;注意点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载的三个文件的安装包的编码要一致，否则整合容易失败&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;本次安装配置所使用版本信息&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Discuz! X3.2&lt;/li&gt;
&lt;li&gt;UCenter 1.6.0&lt;/li&gt;
&lt;li&gt;KPPW2.6.2&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;&lt;strong&gt;1.安装三个系统&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;安装时Ucenter在discuz之前安装即可，安装顺序没有其他额外要求。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;按照官方安装说明安装kkpw&lt;/li&gt;
&lt;li&gt;按照官方安装说明安装Ucenter&lt;/li&gt;
&lt;li&gt;按照官方安装说明安装Discuz

&lt;ul&gt;
&lt;li&gt;安装时选择&lt;code&gt;仅安装 Discuz! X (手工指定已经安装的 UCenter Server)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;填写&lt;code&gt;UCenter 的 URL&lt;/code&gt;一项是，不论是在服务器配置还是在本地配置都选择填写&lt;code&gt;http://127.0.0.1/UCenter安装的路径&lt;/code&gt;，因为直接填写公网ip的话discuz无法识别，然后需要后期手动修改配置文件（修改方法详见第二章节问题1）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;2.修改配置文件&lt;/strong&gt;&lt;/h3&gt;

&lt;h4&gt;1. 问题1：Discuz中集成的UCenter无法访问的问题&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;问题描述：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;登录Discuz后台会发现discuz中已经集成了UCenter,如果配置是在服务器进行，则UCenter点击后无法访问&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;解决办法：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;修改discuz/config/config_ucenter.php,将&lt;code&gt;UC_API&lt;/code&gt;的值改为UCenter的实际访问地址&lt;/p&gt;

&lt;h4&gt;2. 问题2：UCenter集成的应用Discuz通信失败&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;问题描述：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;登录Ucenter点击应用管理，看下整合的应用是否通信成功，如果没有通信成功请修改配置内容&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;解决办法：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;确保应用的主URL是正确的&lt;/li&gt;
&lt;li&gt;应用IP如果空着请填写127.0.0.1&lt;/li&gt;
&lt;li&gt;确保两边通信秘一致&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;3.在kppw中配置UCenter&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;全局配置-&amp;gt;会员整合-&amp;gt;开启&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注意UCenter连接方式请选择mysql，否则容易出错&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;UCenter IP 地址:&lt;/code&gt;填写127.0.0.1（服务器整合的话没有填写该项可能会失败）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;UCenter应用 ID:&lt;/code&gt;填写UCenter整合应用中最大ID号+1&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;进入UCenter查看通信是否成功，如果不成功按照如下思路进行排查&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;应用的主 URL:&lt;/code&gt;是否正确&lt;/li&gt;
&lt;li&gt;&lt;code&gt;应用 IP:&lt;/code&gt;填写是否是127.0.0.1&lt;/li&gt;
&lt;li&gt;两边的通信密钥是够一致&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;4.测试同步注册&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在KPPW于Discuz分别注册一个账号，然后观察UCenter中是否有该账号，如果有则同步注册已经成功一半&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;若出现KPPW无法注册或者登录的情况，请检查KPPW于Discuz中的config_ucenter.php中内容除&lt;code&gt;UC\_KEY&lt;/code&gt;和&lt;code&gt;UC\_APPID&lt;/code&gt;项内容外全部一致，不一致时请参考Discuz配置文件修改KPPW配置文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在KPPW中用Discuz中刚才注册的账号登录，检测能否登录成功，登录成功后则KPPW数据库中添加了Discuz中刚才注册的账号&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;同理在Discuz中用KPPW中刚才注册的账号登录，检测能否登录成功，登录成功后则Discuz数据库中添加了KPPW中刚才注册的账号&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果以上步骤均成功执行，则说明三个系统的同步注册已经整合成功&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;4.测试同步登录与注销&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在KPPW中登录一个账号，然后访问Discuz会发现该账号已经登录（注意：所登录的账号必须在两个系统的数据库已经存储）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在Discuz中登录一个账号，然后访问KPPW会发现该账号已经登录（注意：所登录的账号必须在两个系统的数据库已经存储），如果失败请参考下面内容：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Discuz设置&lt;code&gt;站长-&amp;gt;Ucenter设置-&amp;gt;是否允许其他应用的会员在站点激活:&lt;/code&gt;选择是&lt;/li&gt;
&lt;li&gt;打开两个系统uc_client\data\cache\apps.php文件对比差异(发现KPPW的apps.php文件中的内容较Discus中apps.php文件多了一项配置)&lt;/li&gt;
&lt;li&gt;将KPPW的apps.php文件中的多出的配置复制到Discus中apps.php文件中，然后重新测试，发现已经成功&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      </item>
    
      <item>
        <title>Windows下搭建Tesseract-OCR开发环境</title>
        <link>/2015/07/13/Tesseract-OCR-environment-construction-on-windows.html</link>
        <guid isPermaLink="true">/2015/07/13/Tesseract-OCR-environment-construction-on-windows.html</guid>
        <pubDate>Mon, 13 Jul 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;OCR(Optical Character Recognition):光学字符识别,是指对图片文件中的文字进行分析识别，获取的过程。&lt;/p&gt;

&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;Tesseract：开源的OCR识别引擎，初期Tesseract引擎由HP实验室研发，后来贡献给了开源软件业，后经由Google进行改进，消除bug，优化，重新发布。当前版本为3.02。&lt;/p&gt;

&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;项目地址：&lt;a href=&quot;code.google.com/p/tesseract-ocr&quot;&gt;code.google.com/p/tesseract-ocr&lt;/a&gt;【google code由于被墙，访问需要翻墙】&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;1. 下载安装Tesseract-OCR引擎(3.0版本+才支持中文识别)&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;由于：&lt;a href=&quot;code.google.com/p/tesseract-ocr&quot;&gt;code.google.com/p/tesseract-ocr&lt;/a&gt;被墙，大家想下载也可以翻墙去下，地址为&lt;a href=&quot;https://code.google.com/p/tesseract-ocr/downloads/list&quot;&gt;https://code.google.com/p/tesseract-ocr/downloads/list&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;下载后直接点击安装，一路点击next即可。&lt;/p&gt;

&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;为了方便我将自己的安装版本上传&lt;a href=&quot;http://pan.baidu.com/s/1hmHhc&quot;&gt;tesseract-ocr-setup-3.02.02.exe&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;2. 添加中文字库支持以识别中文&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;进入安装根目录，我们会发现安装目录下有tessdata目录，该目录存放的是语言字库文件，和在命令行界面中可能用到的参数所对应的文件。 &lt;/p&gt;

&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;由于引擎默认安装只含了英文字库，没有包含中文字库，所以想要进行中文识别需要安装中文字体库。，可以到[https://code.google.com/p/tesseract-ocr/downloads/list]  下载对应的语言的字库文件。下载完成后解压，然后将该文件剪切到tessdata目录下去就可以了。&lt;/p&gt;

&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;本机环境搭建所下载语言包&lt;a href=&quot;http://pan.baidu.com/s/1pJKbNFt&quot;&gt;tesseract-ocr-3.02.chi_sim.tar.gz&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;3. 进行文字识别测试&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;转到OCR引擎安装的根目录下，然后打开控制台，输入&lt;code&gt;tesseract&lt;/code&gt;命令，测试该命令是否可用。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;准备一张只含有英文和数字的图片进行测试英文识别测试&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;tesseract 1.png result //1.png是待识别的图片的文件名，result是识别结果输出的文档名称
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;输入上述命令后，会发现文件夹中多了一个result文件,里面即使识别结果。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;准备一张含有中文的图片进行中文识别测试&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;tesseract 1.png result  -l chi_sim //-l chi_sim 表示用简体中文字库
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;附录&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Usage:tesseract imagename outputbase [-l lang] [-psm pagesegmode] &lt;/p&gt;

&lt;p&gt;[configfile...]&lt;/p&gt;

&lt;p&gt;pagesegmode values are:&lt;/p&gt;

&lt;p&gt;0 = Orientation and script detection (OSD) only.&lt;/p&gt;

&lt;p&gt;1 = Automatic page segmentation with OSD.&lt;/p&gt;

&lt;p&gt;2 = Automatic page segmentation, but no OSD, or OCR&lt;/p&gt;

&lt;p&gt;3 = Fully automatic page segmentation, but no OSD. (Default)&lt;/p&gt;

&lt;p&gt;4 = Assume a single column of text of variable sizes.&lt;/p&gt;

&lt;p&gt;5 = Assume a single uniform block of vertically aligned text.&lt;/p&gt;

&lt;p&gt;6 = Assume a single uniform block of text.&lt;/p&gt;

&lt;p&gt;7 = Treat the image as a single text line.&lt;/p&gt;

&lt;p&gt;8 = Treat the image as a single word.&lt;/p&gt;

&lt;p&gt;9 = Treat the image as a single word in a circle.&lt;/p&gt;

&lt;p&gt;10 = Treat the image as a single character.&lt;/p&gt;

&lt;p&gt;-l lang and/or -psm pagesegmode must occur before anyconfigfile.&lt;/p&gt;

&lt;p&gt;tesseract imagename outputbase [-l lang] [-psm pagesegmode] [configfile...]&lt;/p&gt;

&lt;p&gt;tesseract    图片名  输出文件名 -l 字库文件 -psm pagesegmode 配置文件&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;p&gt;tesseract 1.png result  -l chi_sim -psm 7 nobatch&lt;/p&gt;

&lt;p&gt;-l chi_sim 表示用简体中文字库（需要下载中文字库文件，解压后，存放到tessdata目录下去,字库文件扩展名为  .raineddata 简体中文字库文件名为:  chi_sim.traineddata）&lt;/p&gt;

&lt;p&gt;-psm 7 表示告诉tesseract code.jpg图片是一行文本  这个参数可以减少识别错误率.  默认为 3&lt;/p&gt;

&lt;p&gt;configfile 参数值为tessdata\configs 和  tessdata\tessconfigs 目录下的文件名&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>llvm与clang简介</title>
        <link>/2015/07/12/llvm-and-clang-introduction.html</link>
        <guid isPermaLink="true">/2015/07/12/llvm-and-clang-introduction.html</guid>
        <pubDate>Sun, 12 Jul 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;本篇文章主要针对llvm于clang的基本概念做个基本的阐述。刚开始接触llvm与clang的时候只知道clang是一个编译器，那llvm是什么？两者之间的关系是什么？为什么提到llvm必然会提到clang?本篇文章就这些基本概念做个简单的介绍。&lt;/p&gt;

&lt;h3&gt;1. &lt;strong&gt;llvm是什么？&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;llvm是low level virtual machine的简称，其实是一个编译器框架，供了与编译器相关的支持，能够进行程序语言的编译期优化、链接优化、在线编译优化、代码生成。llvm的主要作用是它可以作为多种语言的后端。&lt;/p&gt;

&lt;h3&gt;2. &lt;strong&gt;clang是什么？&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;官方介绍Clang是LLVM native的一个面向C/C++/Objective-C的编译器，目标是要提供一个编译非常快的编译器。&lt;/p&gt;

&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;Clang一般被说是LLVM的一个前端。苹果公司认为GCC的前端越来越不好用，并且不能给苹果的IDE提供很好的服务，所以他们转向了LLVM，Clang的定位就是替代GCC的前端。&lt;/p&gt;

&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;&lt;strong&gt;总结：&lt;/strong&gt;Clang 是一个 C++ 编写、基于 LLVM、发布于 LLVM BSD 许可证下的C/C++/Objective C/Objective C++编译器，其目标（之一）就是超越 GCC。&lt;/p&gt;

&lt;h3&gt;3. &lt;strong&gt;llvm与clang的关系到底是什么？&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;我们需要先了解下LLVM的结构。&lt;/p&gt;

&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;传统的静态编译器分为三个阶段：前端、优化和后端。示意图如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiif2.com1.z0.glb.clouddn.com/2015-07-12-001.png&quot; alt=&quot;图挂了，请联系zhangshuzhou.hi@163.com&quot; title=&quot;Optional title&quot;&gt;&lt;/p&gt;

&lt;div style=&quot;text-align:center&quot;&gt;图1：传统的静态编译器分为三个阶段示意图&lt;/div&gt;

&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;llvm的三阶段的设计如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiif2.com1.z0.glb.clouddn.com/2015-07-12-002.png&quot; alt=&quot;图挂了，请联系zhangshuzhou.hi@163.com&quot; title=&quot;Optional title&quot;&gt;&lt;/p&gt;

&lt;div style=&quot;text-align:center&quot;&gt;图2：llvm的三阶段设计图&lt;/div&gt;

&lt;p&gt;其中clang就是llvm的一个前端，即图2所示的左边部分。&lt;/p&gt;

&lt;h3&gt;4. &lt;strong&gt;编译器为什么要如此设计？&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;这样做的优点是如果需要支持一种新的编程语言，那么我们只需要实现一种新的前端。如果我们需要支持一种新的硬件设备，那我们只需要实现一个新的后端。不论是支持新的编程语言，还是支持新的硬件设备，这里都不需要对优化阶段做修改。&lt;/p&gt;

&lt;h3&gt;参考文献&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/snsn1984/article/details/8037414&quot;&gt;LLVM每日谈之二 LLVM IR &lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>ubuntu12.04重新配置llvm开发环境</title>
        <link>/2015/07/10/llvm-reinstall-on-ubuntu.html</link>
        <guid isPermaLink="true">/2015/07/10/llvm-reinstall-on-ubuntu.html</guid>
        <pubDate>Fri, 10 Jul 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;近期小组用到llvm与clang进行项目开发，小组内部前期分别进行开发没有进行版本统一，但是后期进行系统集成测试的时候需要进行测试环境统一，由于自己之前安装的版本是3.5.1，测试的统一版本是3.6.0，所以需要重新安装llvm。将重新安装的步骤记录如下：&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;1. 卸载llvm3.5.1&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;转到llvm安装的根目录，输入如下命令进行卸载llvm&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;sudo make uninstall
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后输入&lt;code&gt;clang --version&lt;/code&gt;会发现clang已经被彻底删除&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;2.安装llvm3.6.0&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;在正式开始安装llvm3.6.0之前，我们需要做一些准备工作，在&lt;a href=&quot;http://llvm.org/releases/download.html&quot;&gt;http://llvm.org/releases/download.html&lt;/a&gt;下载如下文件&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;llvm源代码：llvm-3.6.0.src.tar.xz&lt;/li&gt;
&lt;li&gt;clang源代码：cfe-3.6.0.src.tar.xz&lt;/li&gt;
&lt;li&gt;compiler-rt源代码：compiler-rt-3.6.0.src.tar.xz&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然后依次输入如下命令进行安装llvm&lt;/p&gt;

&lt;p&gt;1).解压源代码，并配置对应目录结构&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;tar xf llvm-3.6.0.src.tar.xz
mv llvm-3.6.0.src llvm

cd llvm/tools
tar xf cfe-3.6.0.src.tar.xz
mv cfe-3.6.0.src clang

cd ../projects
tar xf compiler-rt-3.6.0.src.tar.xz
mv compiler-rt-3.6.0.src compiler-rt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2).配置编译选项&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;cd ..
./configure --enable-optimized CC=gcc CXX=g++
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3).编译llvm&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;make -j2 //-j2代表用2线程进行源码编译
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译成功后提示&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;llvm[0]: ***** Completed Release+Asserts Build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4).安装编译好的llvm&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5).检查clang的版本&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;clang --version
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果还是旧版本，需要将/usr/bin/clang指向clang 3.6.0：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;ls -s /usr/local/bin/clang /usr/bin/clang
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      </item>
    
      <item>
        <title>windows下搭建jekyll调试博客</title>
        <link>/2015/07/08/windows-install-jekyll-environment.html</link>
        <guid isPermaLink="true">/2015/07/08/windows-install-jekyll-environment.html</guid>
        <pubDate>Wed, 08 Jul 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;首先对安装的整理流程做个简单叙述：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;安装Ruby及Devkit&lt;/li&gt;
&lt;li&gt;使用gem安装Jekyll&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装 Pygments&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;安装 Python&lt;/li&gt;
&lt;li&gt;安装 ‘Easy Install’&lt;/li&gt;
&lt;li&gt;用 “easy_install” 来安装 Pygments&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启动Jekyll&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;故障诊断&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;1. 安装Ruby及Devkit&lt;/strong&gt;&lt;/h3&gt;

&lt;h4&gt;&lt;strong&gt;1). 安装Ruby&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;前往 &lt;a href=&quot;http://rubyinstaller.org/downloads/&quot;&gt;http://rubyinstaller.org/downloads/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在 “RubyInstallers” 部分，选择某个版本点击下载。（笔者安装版本&lt;a href=&quot;http://pan.baidu.com/s/1hqpNBi0&quot;&gt;下载&lt;/a&gt;）
例如， Ruby 2.0.0-p451 (x64) 是适于64位 Windows 机器上的 Ruby 2.0.0 x64 安装包。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过安装包安装&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;最好保持默认的路径 C:\Ruby200-x64， 因为安装包明确提出 “请不要使用带有空格的文件夹 (如： Program Files)”。&lt;/li&gt;
&lt;li&gt;勾选 “Add Ruby executables to your PATH”，这样执行程序会被自动添加至 PATH 而避免不必要的头疼（建议将所有可勾选的项全部进行勾选）。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;验证ruby是否安装成功：打开控制台输入&lt;code&gt;ruby -v&lt;/code&gt;，例如输出&lt;code&gt;ruby 2.1.5p273 (2014-11-13 revision 48405) [x64-mingw32]&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;&lt;strong&gt;2). 安装Devkit&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;DevKit是windows平台下编译和使用本地C/C++扩展包的工具。它就是用来模拟Linux平台下的make,gcc,sh来进行编译。但是这个方法目前仅支持通过RubyInstaller安装的Ruby。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;再次前往 &lt;a href=&quot;http://rubyinstaller.org/downloads/&quot;&gt;http://rubyinstaller.org/downloads/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;下载同系统及 Ruby 版本相对应的 DevKit 安装包。 例如，DevKit-mingw64-64-4.7.2-20130224-1432-sfx.exe 适用于64位 Windows 系统上的 Ruby 2.0.0 x64。(笔者安装的ruby对应的Devkit版本&lt;a href=&quot;http://pan.baidu.com/s/1dDcw84T&quot;&gt;下载&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;运行安装包并解压缩至某文件夹，如 C:\DevKit&lt;/li&gt;
&lt;li&gt;&lt;p&gt;打开控制台，进入解压文件夹目录，输入如下命令&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;ruby dk.rb init
ruby dk.rb install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;安装Devkit出现问题汇总：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.sina.com.cn/s/blog_7444213001018fa7.html&quot;&gt;http://blog.sina.com.cn/s/blog_7444213001018fa7.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;2.使用gem安装Jekyll&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;一般情况下经过第1步骤的安装gem已经安装，我们可以通过输入&lt;code&gt;gem -v&lt;/code&gt;进行检查gem是否安装（Gem是一个管理Ruby库和程序的标准包）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;gem是可以选择源的，默认的源有点慢，可以使用ruby.taobao.org的源&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;查看当源&lt;/p&gt;

&lt;p&gt;输入：   &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;gem sources list
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;***CURRENT SOURCES ***
https://rubygems.org/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;添加新源&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;gem sources -a http://ruby.taobao.org/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;删除默认源&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;gem sources --remove https://rubygems.org/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;再次查看新源,确保只有&lt;code&gt;http://ruby.taobao.org/&lt;/code&gt;就行了&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;直接如下命令即可安装jekyll，该命令会安装jekyll及所有需要的依赖（但不包括插件）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;gem install jekyll
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;网上有人说jekyll的版本1.4.3有个bug,但是我直接安装了最新版本，为2.5.3，没有碰到所谓的bug，估计是新版本已经修复，所以自动略过&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;&lt;strong&gt;3.安装 Pygments&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;Jekyll 里默认的语法高亮插件是 Pygments。 它需要安装 Python。&lt;/p&gt;

&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;不久之前，Jekyll 还添加另一个高亮引擎名为 Rouge， 尽管暂时不如 Pygments 支持那么多的语言，但它是原生 Ruby 程序，而不需要使用 Python。&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;1). 安装 Python&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;建议安装python 2(具体安装略去)&lt;/li&gt;
&lt;li&gt;配置python环境变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;python –V&lt;/code&gt;检查python是否安装成功&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;&lt;strong&gt;2). 安装 ‘Easy Install’&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;浏览 &lt;a href=&quot;https://pypi.python.org/pypi/setuptools#installation-instructions&quot;&gt;https://pypi.python.org/pypi/setuptools#installation-instructions&lt;/a&gt; 来查看详细的安装指南。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于 Windows 7 的机器，下载 &lt;a href=&quot;http://pan.baidu.com/s/1qWl38Gc&quot;&gt;ez_setup.py&lt;/a&gt; 并保存，例如，至C:\。 然后从命令行使用 Python 运行此文件：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;python “C:\ez_setup.py”
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;添加 ‘Python Scripts’ 路径 (如： C:\Python27\Scripts) 至 PATH&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;&lt;strong&gt;3). 用 “easy_install” 来安装 Pygments&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;确保 easy_install 已经正确安装，输入&lt;code&gt;easy_install --version&lt;/code&gt;检查&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用 “easy_install” 来安装 Pygments&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;easy_install Pygments
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;4.启动Jekyll&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;进入待启动的网站目录，然后输入&lt;code&gt;jekyll serve&lt;/code&gt;，然后既可以通过127.0.0.1:4000进行访问&lt;/p&gt;

&lt;h3&gt;参考博客&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/kong5090041/article/details/38408211&quot;&gt;Windows 上安装 Jekyll &lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://segmentfault.com/a/1190000000406011&quot;&gt;使用Jekyll在Github上搭建个人博客&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      </item>
    
      <item>
        <title>git使用笔记</title>
        <link>/2015/07/07/git-use-note.html</link>
        <guid isPermaLink="true">/2015/07/07/git-use-note.html</guid>
        <pubDate>Tue, 07 Jul 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;git作为一个分布式的版本控制工具，其具有集中式版本管理工具所不具有的优点。关于其具体优点不做过多的赘述，下面就git的简单使用进行简单记录&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;预备工作&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;1.注册github账号&lt;/p&gt;

&lt;p&gt;2.window上安装git&lt;/p&gt;

&lt;p&gt;3.配置机器账号&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;$ git config --global user.name &quot;Your Name&quot;
$ git config --global user.email &quot;email@example.com&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.创建SSH Key&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt; ssh-keygen -t rsa -C &quot;youremail@example.com&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;为什么GitHub需要SSH Key呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。&lt;/p&gt;

&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;&lt;strong&gt;1. 从远程仓库克隆&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;假设你需要将某个远程仓库的代码clone下来，那么你就需要用该模块的知识。
例如输入如下命令：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;git clone git@github.com:shuzhou/shuzhou.github.io.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      </item>
    
      <item>
        <title>文件上传的路径获取及回环问题</title>
        <link>/2015/04/30/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%9A%84%E8%B7%AF%E5%BE%84%E8%8E%B7%E5%8F%96%E5%8F%8A%E5%9B%9E%E7%8E%AF%E9%97%AE%E9%A2%98.html</link>
        <guid isPermaLink="true">/2015/04/30/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%9A%84%E8%B7%AF%E5%BE%84%E8%8E%B7%E5%8F%96%E5%8F%8A%E5%9B%9E%E7%8E%AF%E9%97%AE%E9%A2%98.html</guid>
        <pubDate>Thu, 30 Apr 2015 00:00:00 +0800</pubDate>
        <description>&lt;h3&gt;1. ServletContext的getRealPath方法&lt;/h3&gt;

&lt;p&gt;request.getRealPath()这个方法以及被淘汰，所以建议不要使用。&lt;/p&gt;

&lt;p&gt;而获取ServletContext可以用&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;request.getServletContext()（这种支持在servlet3.0以后的）&lt;/li&gt;
&lt;li&gt;request.getSession().getServletContext()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;String uploadPath = request.getSession().getServletContext().getRealPath(&quot;/&quot;);  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：该种方法中的&amp;quot;/&amp;quot;不能用File.separator代替，因为该种方法获取路径值为空&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;2. 采用getResource(&amp;quot;&amp;quot;)获取&lt;/h3&gt;

&lt;p&gt;在web附件上传的时候使用该方法需要配合&lt;code&gt;substring()&lt;/code&gt;函数使用，因为在web中使用该方法的获取的路径值形如&lt;code&gt;file:/C:/Java/apache-tomcat-8.0.12/webapps/bjl-gyw/WEB-INF/lib/commons-fileupload-1.3.jar!/org/apache/commons/fileupload/&lt;/code&gt;，直接使用该路径会产生错误。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;String path = RequestContext.class.getResource(&quot;&quot;).getPath(); 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;主要针对非servlet中，在一般的Java类中使用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;3. 文件上传回环问题&lt;/h3&gt;

&lt;p&gt;在上传文件中，为了防止文件名冲突，一般选择对上传的文件进行重命名，自己重命名的规则一直习惯于ip+time+固定位随机数+原文件名，当我们服务器和客户端在同一台机器时，获取ip地址就产生了回环问题。&lt;/p&gt;

&lt;p&gt;当我们用到&lt;code&gt;httpServletRequest.getRemoteAddr()&lt;/code&gt;的时候，我们在控制台上可以看到遇到了&lt;code&gt;request.getRemoteAddr()&lt;/code&gt;获取的值为0:0:0:0:0:0:0:1，而不是127.0.0.1，这是什么原因呢？
因为0:0:0:0:0:0:0:1是ipv6的格式，其等同于ipv4格式的127.0.0.1。&lt;/p&gt;

&lt;p&gt;解决办法如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;最简单的是你本机访问的时候不用localhost而是用127.0.0.1，这样我们可以看到正常的输出结果&lt;/li&gt;
&lt;li&gt;修改本机的配置文件C:\Windows\System32\drivers\etc下面有一个localhost的文件，你打开后可以看到# ::1 localhost的配置，你可以删除。其中你也可以修改本机的ip，例如你修改一下127.0.0.1为127.0.0.2，当你以后访问的时间127.0.0.2就是你的本机的ip了.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr/&gt;

&lt;p&gt;参考链接：&lt;/p&gt;

&lt;p&gt;[1] &lt;a href=&quot;http://blog.csdn.net/liunian02050328/article/details/8088761&quot;&gt; request.getRemoteAddr()获取的值的问题？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[2] &lt;a href=&quot;http://blog.csdn.net/fengshizty/article/details/28257927?utm_source=tuicool&quot;&gt;JavaEE 保存文件获取绝对路径getResource(&amp;quot;&amp;quot;)和servletContext.getRealPath(&amp;quot;/&amp;quot;) &lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>vim中插件vundle配置</title>
        <link>/2015/04/25/vim%E4%B8%AD%E6%8F%92%E4%BB%B6bundle%E9%85%8D%E7%BD%AE.html</link>
        <guid isPermaLink="true">/2015/04/25/vim%E4%B8%AD%E6%8F%92%E4%BB%B6bundle%E9%85%8D%E7%BD%AE.html</guid>
        <pubDate>Sat, 25 Apr 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;有过vim配置的同学知道，vim配置后可以和IDE媲美，简直是当之无愧的神奇。&lt;/p&gt;

&lt;p&gt;现在我就为大家来介绍一款vim的管理插件 --vundle&lt;/p&gt;

&lt;h3&gt;1. vundle简介&lt;/h3&gt;

&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;Vundle项目托管在github上 &lt;a href=&quot;https://github.com/gmarik/vundle&quot;&gt;https://github.com/gmarik/vundle&lt;/a&gt;，其特色在于使用git来管理插件,更新方便，支持搜索，一键更新，从此只需要一个vimrc走天下.&lt;/p&gt;

&lt;h3&gt;2. vundle配置&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;下载vundle&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;vundle的源码放在github上，所以先将vundle下载到本地&lt;/p&gt;

&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;&lt;code&gt;git clone https://github.com/gmarik/vundle.git  ~/.vim/bundle/vundle&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;配置vim&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;使用命令&lt;code&gt;cd ~&lt;/code&gt;转换到当前用户的根目录下，然后修改.vimrc如所示&lt;a href=&quot;https://github.com/shuzhou/config_file/blob/master/vimrc&quot;&gt;https://github.com/shuzhou/config_file/blob/master/vimrc&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当前用户下根目录输入&lt;code&gt;vim&lt;/code&gt;,然后输入&lt;code&gt;:BundleInstall&lt;/code&gt;,等待插件安装，安装完毕后就可以使用了&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;机器上没有安装git命令的童鞋请主动安装git命令&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo apt-get install git&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      </item>
    
      <item>
        <title>ubuntu中文编码配置</title>
        <link>/2015/04/06/ubuntu%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81%E9%85%8D%E7%BD%AE.html</link>
        <guid isPermaLink="true">/2015/04/06/ubuntu%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81%E9%85%8D%E7%BD%AE.html</guid>
        <pubDate>Mon, 06 Apr 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;linux服务器对中文的支持是一个一直让大家DT的问题，从系统语言配置、中文文件名支持到数据库乱码等偶会经常遇到。所以今天把编码中遇到的问题做一个简单的汇总。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;1. 系统环境语言&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;需要修改文件/etc/default/locale，输入命令如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;sudo vim /etc/default/locale
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;中文设置如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;LANG=&quot;zh_CN.UTF-8&quot;
LANGUAGE=&quot;zh_CN:zh&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;英文设置如下&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;LANG=&quot;en_US.UTF-8&quot;
LANGUAGE=&quot;en_US:en&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;重启服务器生效&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;&lt;strong&gt;2. 终端中文显示乱码&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;需要修改的文件有两处：一个是/etc/environment，另一个是/var/lib/locales/supported.d/local&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;打开/etc/environment,在末尾添加如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;LANG=&quot;zh_CN.UTF-8&quot;
LANGUAGE=&quot;zh_CN:zh:en_US:en&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt; 打开/var/lib/locales/supported.d/local修改为如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;en_US.UTF-8 UTF-8
zh_CN.UTF-8 UTF-8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; 需要输入&lt;code&gt;source /etc/environment&lt;/code&gt; 使得第一个文件配置生效  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; 输入&lt;code&gt;locale-gen&lt;/code&gt; 使得第二个配置生效&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; 原来存在乱码的文件依旧会乱码，重新上传或者新建的中文文件显示正常，无乱码问题&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;经过该步骤的修改，在系统输入locale显示如下:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;LANG=en_US.UTF-8
LANGUAGE=en_US:en
LC_CTYPE=&quot;en_US.UTF-8&quot;
LC_NUMERIC=&quot;en_US.UTF-8&quot;
LC_TIME=&quot;en_US.UTF-8&quot;
LC_COLLATE=&quot;en_US.UTF-8&quot;
LC_MONETARY=&quot;en_US.UTF-8&quot;
LC_MESSAGES=&quot;en_US.UTF-8&quot;
LC_PAPER=&quot;en_US.UTF-8&quot;
LC_NAME=&quot;en_US.UTF-8&quot;
LC_ADDRESS=&quot;en_US.UTF-8&quot;
LC_TELEPHONE=&quot;en_US.UTF-8&quot;
LC_MEASUREMENT=&quot;en_US.UTF-8&quot;
LC_IDENTIFICATION=&quot;en_US.UTF-8&quot;
LC_ALL=
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;不清楚为啥是en_US还能正常显示中文&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;&lt;strong&gt;3. 数据库乱码：&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;其中数据库乱码需要设置四个地方

&lt;ul&gt;
&lt;li&gt; 确保所在系统能够支持中文编码显示，即经过了第二步配置&lt;/li&gt;
&lt;li&gt; 确保Mysql的编码是UTF-8【意思是MYSQL软件编码为UTF-8】&lt;/li&gt;
&lt;li&gt;确保所使用的数据库的编码是UTF-8【即database的编码是UTF-8】&lt;/li&gt;
&lt;li&gt;确保该数据库中每张表的编码是UTF-8【即table的编码是UTF-8】&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; 以上环境配置已经在本机测试成功&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; 关于环境配置的具体原理，至今没有了解清楚，希望懂得人给予讲解或者贴出相关链接，谢谢&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      </item>
    
      <item>
        <title>Python和Java语言对比</title>
        <link>/2015/04/05/Python%E5%92%8CJava%E8%AF%AD%E8%A8%80%E5%AF%B9%E6%AF%94.html</link>
        <guid isPermaLink="true">/2015/04/05/Python%E5%92%8CJava%E8%AF%AD%E8%A8%80%E5%AF%B9%E6%AF%94.html</guid>
        <pubDate>Sun, 05 Apr 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;现在一直习惯于用SSH做WEB开发，但是最近愈来愈感觉对于小的项目工程，Java的SSH框架过于沉重，所以经过调研发现Python语言比较方便，所以最近把python语法看了一遍，故把Python和Java中异同做下对比。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;1. 缩进&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;python需要用缩进来识别语句之前的逻辑块，需要在行尾加上‘：’表示接下来缩进格式相同的语句是一个语句块【python语句末尾可以不加&amp;#39;;&amp;#39;,但是必须&lt;strong&gt;采用缩进&lt;/strong&gt;】&lt;/li&gt;
&lt;li&gt;Java主要用‘{}’和‘；’来识别，不强制要求缩进（同样建议使用缩进格式）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;2. 数&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;python只有四种数据：整数，长整数、浮点数和&lt;strong&gt;复数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;java则有char，short,byte，int，long，float,double类型&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;3. 字符串&lt;/strong&gt;&lt;/h3&gt;

&lt;h4&gt;&lt;strong&gt;3.1. 字符串表示&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt; Python中没有表示单个常量字符串类型的char类型，其可以用单引号‘’、双引号“”来表示一个字符串，也可以用三引号来表示一个多行字符串 &lt;/li&gt;
&lt;li&gt; Java中char表示单个字符，String表示一个字符串，常量字符字符串用双引号“”表示&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;&lt;strong&gt;3.2. 多行字符串&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Python在字符串末尾加上反斜杠（/）表示字符串在下一行继续&lt;/li&gt;
&lt;li&gt;Java用加号（+）表示字符串在下一行继续&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;&lt;strong&gt;3.3. Python中其它的表示方法&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt; python中还有可以在字符串前加前缀r或R：表示自然字符串，即不对字符串做转移处理(比java方便&lt;/li&gt;
&lt;li&gt; Python可以加前缀u或U：表示unicode字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;4. 操作符&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Python中&lt;strong&gt;表示幂计算，如果 X&lt;/strong&gt;y表示 $X^y$&lt;/li&gt;
&lt;li&gt;Python中//表示整除，即商的整数部分&lt;/li&gt;
&lt;li&gt;Python中~表示按位翻转，~x就是-(x+1)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;5. 接口与继承&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Python中继承示例如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Fruit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
           &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;
           &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;fruit&#39;s color: &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;

      &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;grow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
           &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;grow...&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;class Apple(Fruit):                               #继承了父类
      def __init__(self, color):                  
           Fruit.__init__(self, color)            #显示调用父类的__init__方法（Python不会自动调用基本类的__init__()）
           print &quot;apple&#39;s color: %s&quot; % self.color
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;class Banana(Fruit):                              #继承了父类
      def __init__(self, color):                  
           Fruit.__init__(self, color)            #显示调用父类的__init__方法
           print &quot;banana&#39;s color:%s&quot; %s self.color

      def grow(self):                             #覆盖了父类的grow方法
           print &quot;banana grow...&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; Python 中的__init__（）方法类似与Java中的构造函数，Java构造函数中的self默认存在，不需要在构造函数声明的时候进行显示指明，但是Python需要在__init__()函数中显示指明（但是ID调用时不用显示进行self传递）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Python中的接口
Java中的接口接口是为了解决不能多继承的问题，由于Python中支持多继承，所以Python中没有接口的概念。
由于接口是特殊的抽象类，接口没有数据成员，而是一组未实现的方法的集合。要想实现接口的功能，完全可以用一个空的类来做。
例如：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;    class Fruit():  
        def add(self):  
             pass  
        def remove(self):  
             pass  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;6. 对象的序列化表示&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Python中可以使用str（）或repr（）函数来实现对象的序列化&lt;/li&gt;
&lt;li&gt;Java中通过toString()方法来实现对象的序列化&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;7. 参数传递中的*和*&lt;/strong&gt;*&lt;/h3&gt;
</description>
      </item>
    
      <item>
        <title>ubuntu下MySQL开启远程连接</title>
        <link>/2014/12/12/ubuntu%E4%B8%8BMySQL%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5.html</link>
        <guid isPermaLink="true">/2014/12/12/ubuntu%E4%B8%8BMySQL%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5.html</guid>
        <pubDate>Fri, 12 Dec 2014 00:00:00 +0800</pubDate>
        <description>&lt;h3&gt;1. mysql安装后密码无法登陆问题&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;这时你需要进入/etc/mysql目录下，然后查看里面的用户名和密码，然后输入&lt;code&gt;sudo vim debian.cnf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用这个文件中的用户名和密码进入mysql,假如debian.cnf中的用户名为debian-sys-maint,则：&lt;code&gt;mysql -u debian-sys-maint -p&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;按回车，这时需要你输入密码，复制debian.cnf中的密码（不要手动输入，因为容易产生错误）。&lt;/li&gt;
&lt;li&gt;然后修改root用户的密码，如下操作&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;use mysql
show tables;//查看mysql数据库中的表，会看到一个user表。
select * from user;//查看一下这个表中是否有root用户，如果有：
update user set password=password(&quot;root&quot;) where user=&quot;root&quot;;//更改root用户进入mysql的密码。
flush privileges;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;quit退出mysql,然后用root登录 &lt;code&gt;mysql -u root -proot&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;如果user表中没有root用户：用grant命令&lt;code&gt;grant all privileges on *.* to root@localhost identified by&amp;#39;123&amp;#39;&lt;/code&gt;
其中&lt;em&gt;.&lt;/em&gt;代表所有数据库中的所有表，即database name.your table&amp;#39;123&amp;#39;表示为root用户的密码。&lt;/p&gt;

&lt;p&gt;然后输入&lt;code&gt;flush privileges;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后输入&lt;code&gt;select * from user;&lt;/code&gt;查看一下user这个表中是否有root用户。如果有表示添加成功。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;2. 配置远程连接&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vim /etc/mysql/my.cnf&lt;/code&gt; 找到bind-address = 127.0.0.1&lt;/li&gt;
&lt;li&gt;注释掉这行，如：#bind-address = 127.0.0.1 或者改为： bind-address = 0.0.0.0，此表示允许任意IP访问；或者自己指定一个IP地址。&lt;/li&gt;
&lt;li&gt;重启 MySQL：&lt;code&gt;sudo /etc/init.d/mysql restart&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;登录mysql授权用户能进行远程连接 

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;grant all privileges on *.* to root@&amp;quot;%&amp;quot; identified by &amp;quot;password&amp;quot; with grant option;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flush privileges;&lt;/code&gt;
&amp;gt; 第一行命令解释如下，&lt;em&gt;.&lt;/em&gt;：第一个&lt;em&gt;代表数据库名；第二个&lt;/em&gt;代表表名。这里的意思是所有数据库里的所有表都授权给用户。root：授予root账号。“%”：表示授权的用户IP可以指定，这里代表任意的IP地址都能访问MySQL数据库。“password”：分配账号对应的密码，这里密码自己替换成你的mysql root帐号密码。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      </item>
    
      <item>
        <title>Java开发环境配置及常见问题</title>
        <link>/2014/02/11/Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html</link>
        <guid isPermaLink="true">/2014/02/11/Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html</guid>
        <pubDate>Tue, 11 Feb 2014 00:00:00 +0800</pubDate>
        <description>&lt;h3&gt;&lt;strong&gt;1. 下载和安装JDK&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;略&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;2. 配置环境变量&lt;/strong&gt;&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;我的电脑-&amp;gt;属性-&amp;gt;高级系统设置-&amp;gt;环境变量&lt;/li&gt;
&lt;li&gt;在“系统变量”中，设置3项属性，JAVA_HOME,PATH,CLASSPATH(大小写无所谓),若已存在则点击“编辑”，不存在则点击“新建”；&lt;/li&gt;
&lt;li&gt;JAVA_HOME指明JDK安装路径，就是刚才安装时所选择的路径D:/java/jdk1.5.0_08，此路径下包括lib，bin，jre等文件夹（此变量最好设置，因为以后运行tomcat，eclipse等都需要依*此变量）

&lt;ul&gt;
&lt;li&gt;Path使得系统可以在任何路径下识别java命令，设为：%JAVA_HOME%/bin;%JAVA_HOME%/jre/bin&lt;/li&gt;
&lt;li&gt;CLASSPATH为java加载类(class or lib)路径，只有类在classpath中，java命令才能识别，设为：.;%JAVA_HOME%/lib/dt.jar;%JAVA_HOME%/lib/tools.jar (要加.表示当前路径)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;“开始”－&amp;gt;;“运行”，键入“cmd”；&lt;/li&gt;
&lt;li&gt;键入命令“java -version”，“java”，“javac”几个命令，出现画面，说明环境变量配置成功；&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;第三步中%JAVA_HOME%就是引用前面指定的JAVA_HOME；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;&lt;strong&gt;3. Tomcat安装&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;略&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;4. Myeclipse或者eclipse安装&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;需要做的工作如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;配置Tomcat服务器：略&lt;/li&gt;
&lt;li&gt;配置Myeclipse快捷键提示：略&lt;/li&gt;
&lt;li&gt;配置Myeclipse编码：略&lt;/li&gt;
&lt;li&gt;设置myeclipse自动生成的author等注释 

&lt;ul&gt;
&lt;li&gt;window－&amp;gt;preference－&amp;gt;java－&amp;gt;code    styple－&amp;gt;code Template 当你选择到这部的时候就会看见右侧有一个框显示出code这个选项，你点开这个选项，点一下他下面的New Java  files 然后你点edit按钮，把他的内容换成你的就可以了，如
&lt;code&gt;
${filecomment}
${package_declaration}
/**
* @author Tree E-mail:Tree@163.com
* @version 创建时间：${date} ${time}
* 类说明
*/
${typecomment}
${type_declaration}
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;window－&amp;gt;preference－&amp;gt;java－&amp;gt;code    styple－&amp;gt;code Template -&amp;gt; Comments-&amp;gt;Types&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;/**
* @author ${user}
* ${date} ${time}
* ${tags}
*/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改为&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;/**
* @author Tree
* ${date} ${time}
* ${tags}
* /
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;5. SVN插件安装&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;在eclipse的Help-&amp;gt;Eclipse Marketplace中，搜索框输入SVN,然后选择如下图所示的:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiif2.com1.z0.glb.clouddn.com/2014-02-11-001.png&quot; alt=&quot;pic&quot;&gt;&lt;/p&gt;

&lt;p&gt;点击Install，然后全选安装即可。然后点击OK，自动重启即可使用。&lt;/p&gt;

&lt;p&gt;file-&amp;gt;import-&amp;gt;svn-&amp;gt;从SVN检出项目即可使用&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;6. maven插件安装&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;详见地址如下【亲测可行】：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://dead-knight.iteye.com/blog/1841658&quot;&gt;http://dead-knight.iteye.com/blog/1841658&lt;/a&gt;
&lt;a href=&quot;http://blog.csdn.net/guanning0109/article/details/26069277&quot;&gt;http://blog.csdn.net/guanning0109/article/details/26069277&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;附:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://maven.apache.org/download.cgi&quot;&gt;Maven下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://pan.baidu.com/s/1c06My4o&quot;&gt;Maven插件下载链接&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;常见问题汇总：&lt;/strong&gt;&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;安装myeclipse出现failed to find a mian class in c:\windows\temp\的错误，然后中断安装&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;原因：win7的程序运行权限控制十分严格，运行myeclipse 10的安装程序时，首先是将安装包解压到c:\windows\temp的临时文件夹下，再执行该文件夹下的真正安装程序。由于权限不够，系统提示不能找到安装程序主类。&lt;/li&gt;
&lt;li&gt; 解决办法：右击myeclipse 10的安装程序myeclipse-10.0-offline-installer-windows.exe，在弹出窗口中选择“以管理员身份运行”即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;安装myeclipse 选择系统安装盘时无法选择next选项

&lt;ul&gt;
&lt;li&gt;原因：不详&lt;/li&gt;
&lt;li&gt;解决办法：更换安装目录即可&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;[...未完待续，实时更新中...]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;
</description>
      </item>
    
  </channel>
</rss>